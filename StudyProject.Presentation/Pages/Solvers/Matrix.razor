@page "/solvers/Matrix"
@using System.Text
@using StudyProject.Application.Common.Builders
@using System.Numerics
@using TMath.Numerics
@using TMath.Numerics.AdvancedMath.LinearAlgebra
@using TMath.Numerics.Models
@using MathJaxBlazor

<PageTitle>Matrix Operations</PageTitle>

<style>
	.page {
		overflow: hidden;
	}

	.custom-input-field {
		width: 30px;
		height: fit-content;
		background: #282424;
		color: white;
		appearance: none;
		border: none;
		border-radius: 5px;
		padding: 0px 5px 0px 5px;
	}

		/* Hide the up and down arrows */
		.custom-input-field::-webkit-inner-spin-button,
		.custom-input-field::-webkit-outer-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		.custom-input-field[type="number"] {
			-moz-appearance: textfield;
		}
</style>

<h3>Matrix Operations</h3>

<div style="max-width: 75%; display: flex; justify-content: space-between;">
	<div style="text-align: center; margin-top: 20px;">
		<h4>Matrix A: <input type="number" class="custom-input-field" @bind-value="RowsA" /> x <input type="number" class="custom-input-field" @bind-value="ColumnsA" /></h4>
		<div style="display: inline-block;">
			@for (int i = 0; i < rowsA; i++)
			{
				<div>
					@for (int j = 0; j < columnsA; j++)
					{
						<CustomNumber Array="@a" index="i * rowsA + j" />
					}
				</div>
			}
		</div>

		<div style="margin-top: 10px;">
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Transpose(TargetMatrix.MatrixA))">Transpose</CustomButton>
				<CustomButton OnClick="@(() => LUDecomposition(TargetMatrix.MatrixA))">LU Decomposition</CustomButton>
				<CustomButton OnClick="@(() => Inverse(TargetMatrix.MatrixA))">Inverse</CustomButton>
			</div>
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Determinant(TargetMatrix.MatrixA))">Determinant</CustomButton>
				<CustomButton OnClick="@(() => Rank(TargetMatrix.MatrixA))">Rank</CustomButton>
				<CustomButton OnClick="@(() => RowEchelonForm(TargetMatrix.MatrixA))">Row Echelon</CustomButton>
			</div>
		</div>
	</div>
	<div style="text-align: center; margin-top: 20px;">
		<h4>Matrix B: <input type="number" class="custom-input-field" @bind-value="RowsB" /> x <input type="number" class="custom-input-field" @bind-value="ColumnsB" /></h4>
		<div style="display: inline-block;">
			@for (int i = 0; i < rowsB; i++)
			{
				<div>
					@for (int j = 0; j < columnsB; j++)
					{
						<CustomNumber Array="@b" index="i * rowsB + j" />
					}
				</div>
			}
		</div>

		<div style="margin-top: 10px;">
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Transpose(TargetMatrix.MatrixB))">Transpose</CustomButton>
				<CustomButton OnClick="@(() => LUDecomposition(TargetMatrix.MatrixB))">LU Decomposition</CustomButton>
				<CustomButton OnClick="@(() => Inverse(TargetMatrix.MatrixB))">Inverse</CustomButton>
			</div>
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Determinant(TargetMatrix.MatrixB))">Determinant</CustomButton>
				<CustomButton OnClick="@(() => Rank(TargetMatrix.MatrixB))">Rank</CustomButton>
				<CustomButton OnClick="@(() => RowEchelonForm(TargetMatrix.MatrixB))">Row Echelon</CustomButton>
			</div>
		</div>
	</div>

</div>
<Divider />

<!--<CustomButton Width="150px" OnClick="Identity">Identity <input type="number" class="custom-input-field" @bind-value="identitySize" /></CustomButton> -->
<Divider />
<Equation Value="@output" TeXDisplay="false" />
<Divider />
<h3>Step by Step</h3>
<Equation Value="@stepbystep" TeXDisplay="false" />


@code {
	#region Fields and Properties
	int rowsA = 3, rowsB = 3, columnsA = 3, columnsB = 3;

	int RowsA
	{
		get => rowsA;
		set
		{
			rowsA = value;
			Resize(TargetMatrix.MatrixA);
		}
	}

	int RowsB
	{
		get => rowsB;
		set
		{
			rowsB = value;
			Resize(TargetMatrix.MatrixB);
		}
	}

	int ColumnsA
	{
		get => columnsA;
		set
		{
			columnsA = value;
			Resize(TargetMatrix.MatrixA);
		}
	}

	int ColumnsB
	{
		get => columnsB;
		set
		{
			columnsB = value;
			Resize(TargetMatrix.MatrixB);
		}
	}

	ArrayReference<double> a = new(new double[9]), b = new(new double[9]);
	string output = "", stepbystep = "";
	private enum TargetMatrix { MatrixA, MatrixB }

	#endregion

	private void Resize(TargetMatrix target)
	{
		if (target == TargetMatrix.MatrixA)
		{
			a = new ArrayReference<double>(new double[rowsA * columnsA]);
		}
		else
		{
			b = new ArrayReference<double>(new double[rowsB * columnsB]);
		}
	}

	private void Transpose(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		TMatrix<double> transposed = matrix.Transpose();
		output = $"{matrix.ToLaTeX()}^T = {transposed.ToLaTeX()}";
	}

	private void LUDecomposition(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		TLinearAlgebra.LUDecomposition(matrix, out var u, out var l, out var p);
		output = $@"{p.ToLaTeX()} \cdot {matrix.ToLaTeX()} = {l.RoundValues(5).ToLaTeX()} \cdot {u.RoundValues(5).ToLaTeX()}";
	}

	private void Inverse(TargetMatrix target)
	{
		try
		{
			TMatrix<double> matrix;
			if (target == TargetMatrix.MatrixA)
				matrix = new TMatrix<double>(rowsA, columnsA, a.array);
			else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
			TMatrix<double> inverse = TLinearAlgebra.Inverse(matrix);
			output = $@"{matrix.ToLaTeX()}^{{-1}} = {inverse.ToLaTeX()}";
		}
		catch (ArgumentException)
		{
			output = $@"\text{{Matrix must be invertible, that is, }} det(M) \neq 0";
		}
	}

	private void Rank(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		var rank = TLinearAlgebra.Rank(matrix);
		output = $@"\text{{Rank of }} {matrix.ToLaTeX()} = {rank}";
	}

	private void Determinant(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		double determinant = TLinearAlgebra.Determinant(matrix);
		output = $@"{matrix.ToLaTeX("vmatrix")} = {determinant}";
	}

	private void RowEchelonForm(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		var rowEchelon = TLinearAlgebra.RowEchelon(matrix);
		output = $@"\text{{Row Echelon Form of }} {matrix.ToLaTeX()} = {rowEchelon.ToLaTeX()}";
	}
}


