@page "/solvers/Matrix"
@using System.Text
@using StudyProject.Application.Common.Builders
@using System.Numerics
@using TMath.Numerics
@using TMath.Numerics.AdvancedMath.LinearAlgebra
@using TMath.Numerics.Models
@using MathJaxBlazor

<PageTitle>Matrix Operations</PageTitle>

<style>
	.page {
		overflow: hidden;
	}

	.custom-input-field {
		width: 30px;
		height: fit-content;
		background: #282424;
		color: white;
		appearance: none;
		border: none;
		border-radius: 5px;
		padding: 0px 5px 0px 5px;
	}

		/* Hide the up and down arrows */
		.custom-input-field::-webkit-inner-spin-button,
		.custom-input-field::-webkit-outer-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		.custom-input-field[type="number"] {
			-moz-appearance: textfield;
		}
</style>

<h3>Matrix Operations</h3>

<div style="max-width: 75%; display: flex; justify-content: space-between;">
	<div style="text-align: center; margin-top: 20px;">
		<h4>Matrix A: <input type="number" class="custom-input-field" @bind-value="RowsA" /> x <input type="number" class="custom-input-field" @bind-value="ColumnsA" /></h4>
		<div style="display: inline-block;">
			@{
				int indexA = 0;
				@for (int i = 0; i < rowsA; i++)
				{
					<div>
						@for (int j = 0; j < columnsA; j++)
						{
							<CustomNumber Array="@a" index="indexA" />
							indexA++;
						}
					</div>
				}

			}
		</div>

		<div style="margin-top: 10px;">
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Transpose(TargetMatrix.MatrixA))">Transpose</CustomButton>
				<CustomButton OnClick="@(() => LUDecomposition(TargetMatrix.MatrixA))">LU Decomposition</CustomButton>
				<CustomButton OnClick="@(() => Inverse(TargetMatrix.MatrixA))">Inverse</CustomButton>
			</div>
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Determinant(TargetMatrix.MatrixA))">Determinant</CustomButton>
				<CustomButton OnClick="@(() => Rank(TargetMatrix.MatrixA))">Rank</CustomButton>
				<CustomButton OnClick="@(() => RowEchelonForm(TargetMatrix.MatrixA))">Row Echelon</CustomButton>
			</div>
		</div>
	</div>
	<div style="text-align: center; margin-top: 20px;">
		<h4>Matrix B: <input type="number" class="custom-input-field" @bind-value="RowsB" /> x <input type="number" class="custom-input-field" @bind-value="ColumnsB" /></h4>
		<div style="display: inline-block;">
			@{
				int indexB = 0;
				@for (int i = 0; i < rowsB; i++)
				{
					<div>
						@for (int j = 0; j < columnsB; j++)
						{
							<CustomNumber Array="@b" index="indexB" />
							indexB++;
						}
					</div>
				}

			}
		</div>

		<div style="margin-top: 10px;">
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Transpose(TargetMatrix.MatrixB))">Transpose</CustomButton>
				<CustomButton OnClick="@(() => LUDecomposition(TargetMatrix.MatrixB))">LU Decomposition</CustomButton>
				<CustomButton OnClick="@(() => Inverse(TargetMatrix.MatrixB))">Inverse</CustomButton>
			</div>
			<div style="display: flex; justify-content: center;">
				<CustomButton OnClick="@(() => Determinant(TargetMatrix.MatrixB))">Determinant</CustomButton>
				<CustomButton OnClick="@(() => Rank(TargetMatrix.MatrixB))">Rank</CustomButton>
				<CustomButton OnClick="@(() => RowEchelonForm(TargetMatrix.MatrixB))">Row Echelon</CustomButton>
			</div>
		</div>
	</div>

</div>

<Divider />
<CustomButton OnClick="@Add"><Equation Value="A + B" /></CustomButton>
<CustomButton OnClick="@Subtract"><Equation Value="A - B" /></CustomButton>
<CustomButton OnClick="@Multiply"><Equation Value="A \cdot B" /></CustomButton>
<Divider />
<Equation Value="@output" TeXDisplay="false" />
<Divider />
<h3>Step by Step</h3>
<Equation Value="@stepbystep" TeXDisplay="false" />


@code {
	#region Fields and Properties
	int rowsA = 3, rowsB = 3, columnsA = 3, columnsB = 3;

	int RowsA
	{
		get => rowsA;
		set
		{
			rowsA = value;
			Resize(TargetMatrix.MatrixA);
		}
	}

	int RowsB
	{
		get => rowsB;
		set
		{
			rowsB = value;
			Resize(TargetMatrix.MatrixB);
		}
	}

	int ColumnsA
	{
		get => columnsA;
		set
		{
			columnsA = value;
			Resize(TargetMatrix.MatrixA);
		}
	}

	int ColumnsB
	{
		get => columnsB;
		set
		{
			columnsB = value;
			Resize(TargetMatrix.MatrixB);
		}
	}

	ArrayReference<double> a = new(new double[9]), b = new(new double[9]);
	string output = "", stepbystep = "";
	private enum TargetMatrix { MatrixA, MatrixB }

	#endregion

	private void Resize(TargetMatrix target)
	{
		if (target == TargetMatrix.MatrixA)
		{
			a = new ArrayReference<double>(new double[rowsA * columnsA]);
		}
		else
		{
			b = new ArrayReference<double>(new double[rowsB * columnsB]);
		}
	}

	private void Add()
	{
		TMatrix<double> matrixA = new TMatrix<double>(rowsA, columnsA, a.array);
		TMatrix<double> matrixB = new TMatrix<double>(rowsB, columnsB, b.array);
		TMatrix<double> sum = matrixA + matrixB;

		StringBuilder sb = new();
		sb.Append("""\begin{pmatrix}""");
		for (int i = 0; i < sum.Rows; i++)
		{
			for (int j = 0; j < sum.Columns; j++)
			{
				sb.Append($"{matrixA[i, j]} + {matrixB[i, j]}");
				if (j + 1 < sum.Columns)
				{
					sb.Append(" & ");
				}
			}
			sb.Append("""\\""");
		}
		sb.Append("""\end{pmatrix}""");
		stepbystep = $@"\begin{{align*}} {matrixA.ToLaTeX()} + {matrixB.ToLaTeX()} &= {sb.ToString()} \\ &= {sum.ToLaTeX()} \end{{align*}}";

		output = $@"{matrixA.ToLaTeX()} + {matrixB.ToLaTeX()} = {sum.ToLaTeX()}";
	}

	private void Subtract()
	{
		TMatrix<double> matrixA = new TMatrix<double>(rowsA, columnsA, a.array);
		TMatrix<double> matrixB = new TMatrix<double>(rowsB, columnsB, b.array);
		TMatrix<double> difference = matrixA - matrixB;
		output = $@"{matrixA.ToLaTeX()} - {matrixB.ToLaTeX()} = {difference.ToLaTeX()}";


		StringBuilder sb = new();
		sb.Append("""\begin{pmatrix}""");
		for (int i = 0; i < difference.Rows; i++)
		{
			for (int j = 0; j < difference.Columns; j++)
			{
				sb.Append($"{matrixA[i, j]} - {matrixB[i, j]}");
				if (j + 1 < difference.Columns)
				{
					sb.Append(" & ");
				}
			}
			sb.Append("""\\""");
		}
		sb.Append("""\end{pmatrix}""");
		stepbystep = $@"\begin{{align*}} {matrixA.ToLaTeX()} - {matrixB.ToLaTeX()} &= {sb.ToString()} \\ &= {difference.ToLaTeX()} \end{{align*}}";
	}

	private void Multiply()
	{
		Console.WriteLine(string.Join(',', a.array));
		Console.WriteLine(string.Join(',', a.array));
		TMatrix<double> matrixA = new TMatrix<double>(rowsA, columnsA, a.array);
		TMatrix<double> matrixB = new TMatrix<double>(rowsB, columnsB, b.array);
		TMatrix<double> product = matrixA * matrixB;
		output = $@"{matrixA.ToLaTeX()} \cdot {matrixB.ToLaTeX()} = {product.ToLaTeX()}";


		StringBuilder sb = new();

		sb.Append("""\begin{pmatrix}""");

		for (int i = 0; i < matrixA.Rows; i++)
		{
			for (int j = 0; j < matrixB.Columns; j++)
			{
				for (int k = 0; k < matrixA.Columns; k++)
				{
					sb.Append($"{matrixA[i, k]} * {matrixB[k, j]}");
					if (k + 1 < matrixA.Columns)
						sb.Append(" + ");
				}
				if (j + 1 < product.Columns)
				{
					sb.Append(" & ");
				}
			}
			sb.Append("""\\""");
		}

		sb.Append("""\end{pmatrix}""");
		stepbystep = $@"\begin{{align*}} {matrixA.ToLaTeX()} * {matrixB.ToLaTeX()} &= {sb.ToString()}\\ &= {product.ToLaTeX()} \end{{align*}}";
	}


	private void Transpose(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		TMatrix<double> transposed = matrix.Transpose();
		output = $"{matrix.ToLaTeX()}^T = {transposed.ToLaTeX()}";
		stepbystep = @"\text{Simply 'rotate' the matrix so that the columns and rows are now swapped}";
	}

	private void LUDecomposition(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		TLinearAlgebra.LUDecomposition(matrix, out var u, out var l, out var p, out var steps);
		output = $@"{p.ToLaTeX()} \cdot {matrix.ToLaTeX()} = {l.RoundValues(5).ToLaTeX()} \cdot {u.RoundValues(5).ToLaTeX()}";

		StringBuilder sb = new();
		sb.Append(@"\begin{align*}");
		sb.Append("&");
		foreach(var s in steps)
		{
			sb.Append($"{s.CurrentState.ToLaTeX()} {SanitizeLatex(s.NextOperation)}\\\\ &\\sim ");
		}
		sb.Append(u.ToLaTeX());
		sb.Append(@"\end{align*}");
		stepbystep = sb.ToString();
	}

	private void Inverse(TargetMatrix target)
	{
		try
		{
			TMatrix<double> matrix;
			if (target == TargetMatrix.MatrixA)
				matrix = new TMatrix<double>(rowsA, columnsA, a.array);
			else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
			TMatrix<double> inverse = TLinearAlgebra.Inverse(matrix);
			output = $@"{matrix.ToLaTeX()}^{{-1}} = {inverse.ToLaTeX()}";
		}
		catch (ArgumentException)
		{
			output = $@"\text{{Matrix must be invertible, that is, }} det(M) \neq 0";
		}
	}

	private void Rank(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		var rank = TLinearAlgebra.Rank(matrix);
		output = $@"\text{{Rank of }} {matrix.ToLaTeX()} = {rank}";
		stepbystep = @"\text{The rank of a matrix is the number of rows in it's row echelon form with an element different than 0}";
	}

	private void Determinant(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		double determinant = TLinearAlgebra.Determinant(matrix);
		output = $@"{matrix.ToLaTeX("vmatrix")} = {determinant}";
	}

	private void RowEchelonForm(TargetMatrix target)
	{
		TMatrix<double> matrix;
		if (target == TargetMatrix.MatrixA)
			matrix = new TMatrix<double>(rowsA, columnsA, a.array);
		else matrix = new TMatrix<double>(rowsB, columnsB, b.array);
		var rowEchelon = TLinearAlgebra.RowEchelon(matrix, out var steps);
		output = $@"\text{{Row Echelon Form of }} {matrix.ToLaTeX()} = {rowEchelon.ToLaTeX()}";

		StringBuilder sb = new();
		sb.Append(@"\begin{align*}");
		sb.Append("&");
		foreach (var s in steps)
		{
			sb.Append($"{s.CurrentState.ToLaTeX()} {SanitizeLatex(s.NextOperation)}\\\\ &\\sim ");
		}
		sb.Append(rowEchelon.ToLaTeX());
		sb.Append(@"\end{align*}");
		stepbystep = sb.ToString();
	}

	private string SanitizeLatex(string tex)
	{
		if(tex.Contains("Swap", StringComparison.InvariantCultureIgnoreCase))
		{
			return $@"\text{{{tex}}}";
		}
		return tex.Replace("l", "l_").Replace("<--", "\\leftarrow").Replace("*", "\\cdot");
	}
}


